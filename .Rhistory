selectLayer = 1
makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
seq(1,M$nlays)
selectLayer <- 2
makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
selectLayer <- 3
makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
selectLayer <- 4
makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
selectLayer <- 5
makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
readCBCbinByTerm <- function(to.read, term, SP_rng, lay) {
filPtr <- file(to.read, "rb")
bigVector <- vector('numeric')
HeaderRead <- readCBCHeader(filPtr)
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
end <- lay*Lay1floats
i <- 1
cat(paste("0%.."))
if (HeaderRead$TEXT == term  &&
is.element(HeaderRead$KPER, SP_rng &&
thisHeader$KPER <= max(SP_rng))) {
bigVector <- c(bigVector , cbcBlock)
i <- i + 1
} else{
repeat {
thisHeader <- readCBCHeader(filPtr)
# Don't read past EOF
if (length(thisHeader) > 0) {
if (term ==thisHeader$TEXT   &&
is.element(thisHeader$KPER, SP_rng) &&
thisHeader$KPER <= max(SP_rng)) {
i <- i + 1
cbcBlock <-
readBin(filPtr, double(), n = kntFloats, size = 4)
bigVector <- c(bigVector, cbcBlock[strt:end])
# bigVector <- c(bigVector, cbcBlock[1:Lay1floats])
} else {
seek(filPtr, (kntFloats * 4), origin = 'current')
}
}
# don't read everything unless necessary
if (length(thisHeader) == 0) {
cat('\n')
break
}
if (thisHeader$KPER > max(SP_rng)) {
cat('\n')
break
}
# Display % complete
cat(paste('\r',format(as.numeric(thisHeader$KPER) / max(SP_rng) * 100,digits = 2,nsmall = 2),"%"))
}
}
close(filPtr)
return(bigVector)
}
source('R:/rModflow/R/modflowDataFuncs.R')
source('R:/ModflowBinary/MeanCBB_TermByAllLayer.R')
data <- listenv()
ix=0
tictoc::tic("Raster Creation")
for (selectLayer in seq(1,M$nlays)){
#=================================================================
# Retrieve CBC by Layer using multiple processors
#=================================================================
cat(paste("Start making rasters for",term,"Layer",selectLayer, '\n'))
ix = ix + 1
data[[ix]]<-  makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
}
readCBCbinByTerm <- function(to.read, term, SP_rng, lay) {
filPtr <- file(to.read, "rb")
bigVector <- vector('numeric')
HeaderRead <- readCBCHeader(filPtr)
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
end <- lay*Lay1floats
i <- 1
cat(paste("0%.."))
if (HeaderRead$TEXT == term  &&
is.element(HeaderRead$KPER, SP_rng &&
thisHeader$KPER <= max(SP_rng))) {
bigVector <- c(bigVector , cbcBlock)
i <- i + 1
} else{
repeat {
thisHeader <- readCBCHeader(filPtr)
# Don't read past EOF
if (length(thisHeader) > 0) {
if (term ==thisHeader$TEXT   &&
is.element(thisHeader$KPER, SP_rng) &&
thisHeader$KPER <= max(SP_rng)) {
i <- i + 1
cbcBlock <-
readBin(filPtr, double(), n = kntFloats, size = 4)
bigVector <- c(bigVector, cbcBlock[strt:end])
# bigVector <- c(bigVector, cbcBlock[1:Lay1floats])
} else {
seek(filPtr, (kntFloats * 4), origin = 'current')
}
}
# don't read everything unless necessary
if (length(thisHeader) == 0) {
cat('\n')
break
}
if (thisHeader$KPER > max(SP_rng)) {
cat('\n')
break
}
# Display % complete
cat(paste('\r',format(as.numeric(thisHeader$KPER) / max(SP_rng) * 100,digits = 2,nsmall = 2),"%"))
}
}
close(filPtr)
return(bigVector)
}
data <- listenv()
ix=0
tictoc::tic("Raster Creation")
for (selectLayer in seq(1,M$nlays)){
#=================================================================
# Retrieve CBC by Layer using multiple processors
#=================================================================
cat(paste("Start making rasters for",term,"Layer",selectLayer, '\n'))
ix = ix + 1
data[[ix]]<-  makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
}
for (selectLayer in seq(1,M$nlays)){
#=================================================================
# Retrieve CBC by Layer using multiple processors
#=================================================================
cat(paste("Start making rasters for",term,"Layer",selectLayer, '\n'))
ix = ix + 1
data[[ix]]<-  makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
}
term
SP_rng
TtlStrPd
fileSz
#=================================================================
# Function definition used to create mean rasters from binary
# cell by cell budget terms for all stress periods by layer
#=================================================================
makeMeanLayer<- function(cbbFile,selectLayer,SP_rng,term){
# to.read <- file(cbbFile, "rb")
print (paste("Retrieving", trimws(CBCterms[[n1]])))
term2Read <-trimws(CBCterms[[n1]])
maxSP <- as.integer(TtlStrPd)
tictoc::tic(paste('Reading CBC for for layer ',selectLayer))
#=================================================================
#  call rModflow function to read from CBC binary file.
#=================================================================
CBCdata1 <- rModflow::readCBCbinByTerm(cbbFile, term, SP_rng, selectLayer)
tictoc::toc()
#=================================================================
# Reformat CBCdata1 as 3D array using col, row, StressPeriod dimensions
# create dataframe of Budget values for this Layer
#=================================================================
CBCsMatrix<- array(CBCdata1,c(M$ncols,M$nrows,maxSP))
tictoc::tic(paste('Creating mean raster for layer ',selectLayer))
xf <-future.apply::future_apply(CBCsMatrix,MARGIN=c(1,2),FUN=mean,na.rm=T)
MeanSim <- t(xf[,])
#=================================================================
# NAD83 HARN StatePlane Florida East FIPS 0901 Feet
#=================================================================
HARNSP17ft  = CRS("+init=epsg:2881")
HARNUTM17Nm  = CRS("+init=epsg:3747")
latlongs = CRS("+proj=longlat +datum=WGS84")
#=================================================================
# calculate number of rows and columns
#=================================================================
res=MFmodel.Params[model,]$res
xmin=MFmodel.Params[model,]$xmin
ymin=MFmodel.Params[model,]$ymin
rasRows=MFmodel.Params[model,]$nrows
rasCols=MFmodel.Params[model,]$ncols
xmax=xmin+(res*rasCols)
ymax=ymin+(res*rasRows)
#=================================================================
# define raster and map extents using MFmodel data extents
#=================================================================
cellsize=c(res,res)
ras <- raster::raster(res=cellsize, xmn=xmin,xmx=xmax,ymn=ymin,ymx=ymax,crs=HARNSP17ft)
rasExt <- raster::extent(ras)
#=================================================================
# create raster from meanSim matrix
#=================================================================
MeanRasL1<-raster::raster(MeanSim,xmin,xmax,ymin,ymax, crs=HARNSP17ft)
# #=================================================================
# # does not print.  Just available for debugging.
# #=================================================================
# my.at = c(minValue(MeanRasL1),-1,1,maxValue(MeanRasL1))
# yourTheme = rasterVis::rasterTheme(region = RColorBrewer::brewer.pal('BrBG', n = 9))
# lattice::levelplot(MeanRasL1,par.settings = yourTheme,at=my.at)
# Sys.sleep(0)
#=================================================================
# Export raster as tiff file
#=================================================================
basePath <- dirname(cbbFile)
filename = paste0(basePath,'/Mean_',term2Read,'_Lay',selectLayer,'.tif')
raster::writeRaster(MeanRasL1, filename, format="GTiff", overwrite=TRUE)
}
data <- listenv()
ix=0
tictoc::tic("Raster Creation")
for (selectLayer in seq(1,M$nlays)){
#=================================================================
# Retrieve CBC by Layer using multiple processors
#=================================================================
cat(paste("Start making rasters for",term,"Layer",selectLayer, '\n'))
ix = ix + 1
data[[ix]]<-  makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
}
makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
cbbFile
selectLayer
# to.read <- file(cbbFile, "rb")
print (paste("Retrieving", trimws(CBCterms[[n1]])))
term2Read <-trimws(CBCterms[[n1]])
maxSP <- as.integer(TtlStrPd)
tictoc::tic(paste('Reading CBC for for layer ',selectLayer))
#=================================================================
#  call rModflow function to read from CBC binary file.
#=================================================================
CBCdata1 <- rModflow::readCBCbinByTerm(cbbFile, term, SP_rng, selectLayer)
#=================================================================
#  call rModflow function to read from CBC binary file.
#=================================================================
CBCdata1 <- readCBCbinByTerm(cbbFile, term, SP_rng, selectLayer)
to.read
readCBCbinByTerm <- function(cbbFile, term, SP_rng, lay) {
filPtr <- file(cbbFile, "rb")
bigVector <- vector('numeric')
HeaderRead <- readCBCHeader(filPtr)
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
end <- lay*Lay1floats
i <- 1
cat(paste("0%.."))
if (HeaderRead$TEXT == term  &&
is.element(HeaderRead$KPER, SP_rng &&
thisHeader$KPER <= max(SP_rng))) {
bigVector <- c(bigVector , cbcBlock)
i <- i + 1
} else{
repeat {
thisHeader <- readCBCHeader(filPtr)
# Don't read past EOF
if (length(thisHeader) > 0) {
if (term ==thisHeader$TEXT   &&
is.element(thisHeader$KPER, SP_rng) &&
thisHeader$KPER <= max(SP_rng)) {
i <- i + 1
cbcBlock <-
readBin(filPtr, double(), n = kntFloats, size = 4)
bigVector <- c(bigVector, cbcBlock[strt:end])
# bigVector <- c(bigVector, cbcBlock[1:Lay1floats])
} else {
seek(filPtr, (kntFloats * 4), origin = 'current')
}
}
# don't read everything unless necessary
if (length(thisHeader) == 0) {
cat('\n')
break
}
if (thisHeader$KPER > max(SP_rng)) {
cat('\n')
break
}
# Display % complete
cat(paste('\r',format(as.numeric(thisHeader$KPER) / max(SP_rng) * 100,digits = 2,nsmall = 2),"%"))
}
}
close(filPtr)
return(bigVector)
}
#=================================================================
# Function definition used to create mean rasters from binary
# cell by cell budget terms for all stress periods by layer
#=================================================================
makeMeanLayer<- function(cbbFile,selectLayer,SP_rng,term){
print (paste("Retrieving", trimws(CBCterms[[n1]])))
term2Read <-trimws(CBCterms[[n1]])
maxSP <- as.integer(TtlStrPd)
tictoc::tic(paste('Reading CBC for for layer ',selectLayer))
#=================================================================
#  call rModflow function to read from CBC binary file.
#=================================================================
CBCdata1 <- readCBCbinByTerm(cbbFile, term, SP_rng, selectLayer)
# CBCdata1 <- rModflow::readCBCbinByTerm(cbbFile, term, SP_rng, selectLayer)
tictoc::toc()
#=================================================================
# Reformat CBCdata1 as 3D array using col, row, StressPeriod dimensions
# create dataframe of Budget values for this Layer
#=================================================================
CBCsMatrix<- array(CBCdata1,c(M$ncols,M$nrows,maxSP))
tictoc::tic(paste('Creating mean raster for layer ',selectLayer))
xf <-future.apply::future_apply(CBCsMatrix,MARGIN=c(1,2),FUN=mean,na.rm=T)
MeanSim <- t(xf[,])
#=================================================================
# NAD83 HARN StatePlane Florida East FIPS 0901 Feet
#=================================================================
HARNSP17ft  = CRS("+init=epsg:2881")
HARNUTM17Nm  = CRS("+init=epsg:3747")
latlongs = CRS("+proj=longlat +datum=WGS84")
#=================================================================
# calculate number of rows and columns
#=================================================================
res=MFmodel.Params[model,]$res
xmin=MFmodel.Params[model,]$xmin
ymin=MFmodel.Params[model,]$ymin
rasRows=MFmodel.Params[model,]$nrows
rasCols=MFmodel.Params[model,]$ncols
xmax=xmin+(res*rasCols)
ymax=ymin+(res*rasRows)
#=================================================================
# define raster and map extents using MFmodel data extents
#=================================================================
cellsize=c(res,res)
ras <- raster::raster(res=cellsize, xmn=xmin,xmx=xmax,ymn=ymin,ymx=ymax,crs=HARNSP17ft)
rasExt <- raster::extent(ras)
#=================================================================
# create raster from meanSim matrix
#=================================================================
MeanRasL1<-raster::raster(MeanSim,xmin,xmax,ymin,ymax, crs=HARNSP17ft)
# #=================================================================
# # does not print.  Just available for debugging.
# #=================================================================
# my.at = c(minValue(MeanRasL1),-1,1,maxValue(MeanRasL1))
# yourTheme = rasterVis::rasterTheme(region = RColorBrewer::brewer.pal('BrBG', n = 9))
# lattice::levelplot(MeanRasL1,par.settings = yourTheme,at=my.at)
# Sys.sleep(0)
#=================================================================
# Export raster as tiff file
#=================================================================
basePath <- dirname(cbbFile)
filename = paste0(basePath,'/Mean_',term2Read,'_Lay',selectLayer,'.tif')
raster::writeRaster(MeanRasL1, filename, format="GTiff", overwrite=TRUE)
}
data <- listenv()
ix=0
tictoc::tic("Raster Creation")
for (selectLayer in seq(1,M$nlays)){
#=================================================================
# Retrieve CBC by Layer using multiple processors
#=================================================================
cat(paste("Start making rasters for",term,"Layer",selectLayer, '\n'))
ix = ix + 1
data[[ix]]<-  makeMeanLayer(cbbFile,selectLayer,SP_rng,term)
}
readCBCbinByTerm <- function(cbbFile, term, SP_rng, lay) {
filPtr <- file(cbbFile, "rb")
bigVector <- vector('numeric')
HeaderRead <- readCBCHeader(filPtr)
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
end <- lay*Lay1floats
i <- 1
cat(paste("0%.."))
if (HeaderRead$TEXT == term  &&
is.element(HeaderRead$KPER, SP_rng &&
thisHeader$KPER <= max(SP_rng))) {
bigVector <- c(bigVector , cbcBlock)
i <- i + 1
} else{
repeat {
thisHeader <- readCBCHeader(filPtr)
# Don't read past EOF
if (length(thisHeader) > 0) {
if (term ==thisHeader$TEXT   &&
is.element(thisHeader$KPER, SP_rng) &&
thisHeader$KPER <= max(SP_rng)) {
i <- i + 1
cbcBlock <-
readBin(filPtr, double(), n = kntFloats, size = 4)
bigVector <- c(bigVector, cbcBlock[strt:end])
# bigVector <- c(bigVector, cbcBlock[1:Lay1floats])
} else {
seek(filPtr, (kntFloats * 4), origin = 'current')
}
}
# don't read everything unless necessary
if (length(thisHeader) == 0) {
cat('\n')
break
}
if (thisHeader$KPER > max(SP_rng)) {
cat('\n')
break
}
# Display % complete
cat(paste('\r',format(as.numeric(thisHeader$KPER) / max(SP_rng) * 100,digits = 2,nsmall = 2),"%"))
}
}
close(filPtr)
return(bigVector)
}
cbbFile
filPtr <- file(cbbFile, "rb")
bigVector <- vector('numeric')
HeaderRead <- readCBCHeader(filPtr)
HeaderRead
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
lay = 1
filPtr <- file(cbbFile, "rb")
bigVector <- vector('numeric')
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
end <- lay*Lay1floats
i <- 1
cat(paste("0%.."))
if (HeaderRead$TEXT == term  &&
is.element(HeaderRead$KPER, SP_rng &&
thisHeader$KPER <= max(SP_rng))) {
bigVector <- c(bigVector , cbcBlock)
i <- i + 1
} else{
repeat {
thisHeader <- readCBCHeader(filPtr)
# Don't read past EOF
if (length(thisHeader) > 0) {
if (term ==thisHeader$TEXT   &&
is.element(thisHeader$KPER, SP_rng) &&
thisHeader$KPER <= max(SP_rng)) {
i <- i + 1
cbcBlock <-
readBin(filPtr, double(), n = kntFloats, size = 4)
bigVector <- c(bigVector, cbcBlock[strt:end])
# bigVector <- c(bigVector, cbcBlock[1:Lay1floats])
} else {
seek(filPtr, (kntFloats * 4), origin = 'current')
}
}
# don't read everything unless necessary
if (length(thisHeader) == 0) {
cat('\n')
break
}
if (thisHeader$KPER > max(SP_rng)) {
cat('\n')
break
}
# Display % complete
cat(paste('\r',format(as.numeric(thisHeader$KPER) / max(SP_rng) * 100,digits = 2,nsmall = 2),"%"))
}
}
thisHeader
filPtr <- file(cbbFile, "rb")
bigVector <- vector('numeric')
HeaderRead <- readCBCHeader(filPtr)
kntFloats <- HeaderRead$K * HeaderRead$NR * HeaderRead$NC
Lay1floats <- HeaderRead$NR * HeaderRead$NC
cbcBlock <- readBin(filPtr, double(), n = kntFloats, size = 4)
strt<-1+((lay-1)*Lay1floats)
end <- lay*Lay1floats
i <- 1
cat(paste("0%.."))
if (HeaderRead$TEXT == term  &&
is.element(HeaderRead$KPER, SP_rng &&
thisHeader$KPER <= max(SP_rng))) {
bigVector <- c(bigVector , cbcBlock)
i <- i + 1
} else{
repeat {
thisHeader <- readCBCHeader(filPtr)
# Don't read past EOF
if (length(thisHeader) > 0) {
if (term ==thisHeader$TEXT   &&
is.element(thisHeader$KPER, SP_rng) &&
thisHeader$KPER <= max(SP_rng)) {
i <- i + 1
cbcBlock <-
readBin(filPtr, double(), n = kntFloats, size = 4)
bigVector <- c(bigVector, cbcBlock[strt:end])
# bigVector <- c(bigVector, cbcBlock[1:Lay1floats])
} else {
seek(filPtr, (kntFloats * 4), origin = 'current')
}
}
# don't read everything unless necessary
if (length(thisHeader) == 0) {
cat('\n')
break
}
if (thisHeader$KPER > max(SP_rng)) {
cat('\n')
break
}
# Display % complete
cat(paste('\r',format(as.numeric(thisHeader$KPER) / max(SP_rng) * 100,digits = 2,nsmall = 2),"%"))
}
}
KPER
i
end
cbcBlock
